PLAN:

** GENERAL/FUTURE TO-DO

    * Packaging:
        * Make Python package (ignore Imfit library compilation for now)
            [x] Make text file summarizing how to compile/build package in current form

        * Test upload to TestPyPI and installation
            [ ] Make virtualenv
            [ ] Trial upload of wheel
            [ ] Trial installation in virtualenv

        * Include compilation of Imfit library
            [ ] Look up notes on how to include Cython compilation in a package build

            http://martinsosic.com/development/2016/02/08/wrapping-c-library-as-python-module.html#summary

    * Documentation:
        [ ] Check how to set up doc input files for readthedocs

            [x] Look up how to do Sphinx setup/quickstart (e.g., how to generate setup.py file)
            [x] Do Sphinx setup/quickstart

            [x] Test Sphinx documentation generation

       [ ] Make basic how-to/summary file (useful for me)

       [ ] Add API documentation
            [ ] Add documentation file for config.py
            [ ] Add documentation file for descriptions.py
            [ ] Add documentation file for imfit_funcs.py
            [ ] Add documentation file for utils.py

    * Rework package to make it astropy-compatible




[X] We need the following internal flag variables in Imfit:
	has-FinalSetupForFitting-been-called?
		_finalSetupDone
	has-fit-been-done? (converged *or* terminated)
		_fitDone
	has-fit-statistic-been-computed?
		_fitStatComputed

	Currently, Imfit has the following *properties*:
		.fitConverged = return self._modelObjectWrapper.fitConverged
			= [ModelObjectWrapper] return (self._fitStatus > 0) and (self._fitStatus < 5)
		.fitTerminated = return self._modelObjectWrapper.fitTerminated
			= [ModelObjectWrapper] return self._fitStatus >= 5

	In ModelObjectWrapper
		_fitStatus = int, initially 0; then = return value from DispatchToSolver

[X] Imfit.doFit method
	-- specifies which solver to use
	-- initiates the fit

	[X] doFit method
    def doFit( self, solver='LM' ):
        if solver not in ['LM', 'NM', 'DE']:
            raise Exception('Invalid solver name: {0}'.format(solver))
        self._modelObjectWrapper.fit(verbose=self._verboseLevel, mode=solver)
        if not self.fitError:
            self._fitDone = True
            self._fitStatComputed = True

	[X] Modify ModelObjectWrapper.fit
		-- *remove* self._model.FinalSetupForFitting() call

	[X] ModelObjectWrapper.doFinalSetup method
		-- if NOT _finalSetupDone: calls ModelObject::FinalSetupForFitting

[X] Imfit.loadData method
	-- optional PSF data
		-- set this first!
	-- loads data and image-description parameters and fit-statistic selection
	-- calls FinalSetupForFitting
	[X] Main refactoring (don't include PSF option)

	[X] Modify ModelObjectWrapper.loadData
		-- status = self._model.FinalSetupForFitting() right at the end
		-- set internal _finalSetupDone flag

	[X] Add PSF option

[X] Refactor existing Imfit.fit method to call .loadData and then .doFit
	[X] Refactor
	[X] Run unit & regression tests


[x] Test use of PSF convolution in computation of fit statistics and fitting
    PSF convolution in test_fitting_and_fitstatistic.py is currently not working!
    -- Problem is: PSF image is *not* being normalized?
    Normalization w/in C++ imfit (setup_model_object.cpp):
    status = newModelObj->AddPSFVector(nPixels_psf, nColumns_psf, nRows_psf, psfPixels,
    									options->normalizePSF);

    Normalization in pyimfit
       def setPSF(self, np.ndarray[np.double_t, ndim=2, mode='c'] psf):
        self._model.AddPSFVector(n_cols_psf * n_rows_psf, n_cols_psf, n_rows_psf, &self._psfData[0])

    def _setupModel(self):
           if self._psf is not None:
            self._modelObjectWrapper.setPSF(np.asarray(self._psf))

    [x] Add normalize option/keyword to Imfit class
        [x] Add as property with default value = True

        [x] Modify Imfit._setupModel to include normalize flag value as input to setPSF

        [x] Modify ModelObjectWrapper.setPSF to accept normalization flag and pass it on
        to ModelObject::AddPSFVector

        [x] Run tests in test_fitting_and_fitstatistic.py

        [x] Add option for specifying *no* PSF normalization
            -- should be sample place we pass in the PSF image!




[ ] Modify Imfit: add ability to change parameter *values*
	-- necessary if we want to use Imfit to get fit statistic *without* running
	a fit
	-- useful if user wants to re-run a fit with different starting parameters
	-- for now: we want to be able to supply a list/ndarray of parameter *values*,
	without touching the parameter limits
	-- Two modes:
		1. Pass parameter values to ModelObject::GetFitStatistic
		2. Update the parameter values in Imfit object (for future fits)

	Current ModelObjectWrapper.getFitStatistic(mode) does this:
    def getFitStatistic( self, mode='none' ):
        cdef double fitstat
        if self.fittedLM: -- i.e., if there was a successful fit with LM
            fitstat = self._fitResult.bestnorm
        else:
            fitstat = self._model.GetFitStatistic(self._paramVect)

	[and then returns a modified value -- e.g., reduced, AIC, BIC -- depending
	on value of "mode"]

	[X] New method in ModelObjectWrapper
	computeFitStatistic( self, parameterVector=None ):
		[ type for parameterVector = np.ndarray[np.double_t, ndim=1, mode='c'] ?]
		if parameterVictor is None:
			fitstat = self._model.GetFitStatistic(self._paramsVect)
		else:
			# possibly convert parameterVector to double *
			fitstat = self._model.GetFitStatistic(parameterVector)

	[X] Corresponding method for Imfit

	[X] Add extra unit tests


	Basically, we need to update ModelObjectWrapper._paramVect

	[ ] Updating of current parameter vector in ModelObjectWrapper:
		[ ] Quick and dirty modification:
			[ ] Add .updateParameterValues method to ModelObjectWrapper
				-- should update ModelObjectWrapper._paramVect
			[ ] Add .updateParameterValues method to Imfit
				-- should call ModelObjectWrapper._paramVect on self._modelObjectWrapper


	MAYBE LATER:
	[ ] Check to see if there's a way to modify parameter values in an existing
	ModelDescription instance

	[ ] Modify ParameterDescription
		[ ] Change "value" property so we can set it as well as read it

	[ ] Modify ModelDescription
		[ ] ModelDesription.updateParameterValues

	[ ] Modify Imfit to allow updating of parameter values
		-- i.e., call

[X] Test whether we can call Imfit.fitStatistic w/o running fit



** ADD OVERSAMPLED-PSF SUPPORT TO PYIMFIT

In current imfit/makeimage code, this is done in SetupModelObject

  [[ *after* PSF vector is added, if any ]]

  [[ *after* adding data image [or specifying model image size in makeimage mode] ]]
    -- this also makes sense from the standpoint of wanting to have the data/model
    image dimensions so we can tell if the oversampling regions are within the image

  if (options->psfOversampling) {
    for (int i = 0; i < (int)psfOversampleInfoVect.size(); i++) {
      status = newModelObj->AddOversampledPsfInfo(psfOversampleInfoVect[i]);
      if (status < 0) {
        fprintf(stderr, "*** ERROR: Failure in ModelObject::AddOversampledPsfInfo!\n\n");
  	    exit(-1);
      }
    }
  }


So we need a way of creating PsfOversamplingInfo objects, and passing pointers
to them
    We need to add PsfOversamplingInfo to ModelObjectWrapper, via Imfit
    -- PsfOversamplingInfo can only be added to ModelObject
        1. *After* data image added (or model image setup):
            nDataColumns and nDataRows must already be set
        2. *After* PSF image (if any) has been added

    Current way to do this is via keyword in call to ModelObjectWrapper.loadData()
        psf_oversampling_list

    [X] Add declaration of PsfOversamplingInfo to imfit_lib.pxd

    [X] Figure out when we need to or can add psf oversampling info to ModelObject
        *After* data image added (or model image setup):
            nDataColumns and nDataRows must already be set
        *After* PSF image (if any) has been added

    [X] Add keyword parameter for oversampling-info objects to ModelObjectWrapper.

    [X] Add wrapper method around ModelObject::AddOversampledPsfInfo to ModelObjectWrapper

    [X] Make unit/regression test for use of PSF oversampling

    [ ] Later: add separate method to Imfit class allowing user to pass in
    just the oversampling info?


ModelObjectWrapper:
    cdef addOversamplingInfo(self, PsfOversampling oversamplingInfo):


    keyword in loadData:
       psf_oversampling_list : list of PsfOversampling
            List of PsfOversampling objects, describing oversampling regions, PSFs,
            and oversampling scales.






* As a reminder, imfit does the following, in this order
1. Creates ModelObject and loads data, error, mask, PSF, image-description info
(via SetupModelObject)
	Adds PSF *first*, then adds data, etc. [because when we add data with
	AddImageDataVector, SetupModelImage is then automatically called, and
	the internal model-image dimensions are determined, and so *if* we're
	using a PSF, its dimensions need to already be in place]
	

2. Adds image functions to ModelObject (via AddFunctions)

[I *believe* that 1 and 2 can be done in either order...]

3. ModelObject->FinalSetupForFitting()

[then we add info about parameter, etc.]


    imfit_fitter = Imfit(model_desc)
    imfit_fitter.loadData(image_ic3478, gain=4.725, read_noise=4.3, original_sky=130.14)


* pyimfit currently works this way
1. Instantiate Imfit object, storing the input ModelDescription and PSF data
    ex: imfit_fitter = Imfit(model_desc)
    ex: imfit_fitter = Imfit(model_desc, psfImage)

2. Supply image data (and image-description info, like gain)
    ex: imfit_fitter.loadData(image_ic3478, gain=4.725, read_noise=4.3, original_sky=130.14)

3. Call Imfit.fit, which
	A. calls _setupModel(), which instantiates ModelObjectWrapper object, 
	passing it the ModelDescription
	Then, inside ModelObjectWrapper, we do
		self._model = new ModelObject()
        self._model.SetDebugLevel(debug_level)
        self._model.SetVerboseLevel(verbose_level)
        self._addFunctions(self._modelDescr, subsampling=subsampling, verbose=verbose_level)
        self._paramSetup(self._modelDescr)
        
    Then, PSF data (if any) is passed to ModelObjectWrapper object via
    	self._modelObjectWrapper.setPSF(np.asarray(self._psf))

	B. Sends data, etc. to ModelObjectWrapper object via
		self._modelObjectWrapper.loadData(image, error, mask, **kwargs)
		
	C. Calls FinalSetupForFitting *and* initiates the fit via
		self._modelObjectWrapper.fit(verbose=self._verboseLevel, mode=mode)

So, in conceptual summary
	1. Create ModelObject and add functions (and param info)
	2. Add PSF
	3. Add data
	4. FinalSetupForFitting()
	5. Run fit


model_object.cpp:
/* ---------------- PUBLIC METHOD: SetupModelImage -------------------- */
// Called by AddImageDataVector(); can also be used by itself in make-image
// mode. Tells ModelObject to allocate space for the model image.
// Note that if PSF convolution is being done, then AddPSFVector() must be
// called *before* this method.



supply data
supply PSF
	==> call FinalSetupForFitting

supply PSF
supply data
	==> call FinalSetupForFitting

supply data (not using PSF)
	==> ??

Why we might want to supply PSF *first*, separate from data image, etc.
	-- What if user wants to re-run fit with updated mask image?
	-- What if user wants to re-run fit with changed image section?


1. Add doFinalSetup method to Imfit (and ModelObjectWrapper)

2. Modify ModelObjectWrapper.fit so that it checks to see if ModelObject::FinalSetupForFitting
has already been called; if not, 



PROBLEMS:

When user calls Imfit.fitStatistic, .reducedFitStatistic, .AIC, or .BIC
	-- Do we re-compute the fit statistic?
	-- What if fit statistic already exists?


Imfit.fit(...)
        self._modelObjectWrapper.loadData(image, error, mask, **kwargs)
        self._dataSet = True
        self._modelObjectWrapper.fit(verbose=self._verboseLevel, mode=mode)

    @property
    def fitStatistic(self):
        """
        The :math:`\\chi^2`, Poisson MLR, or Cash statistic of the fit.
        """
        return self._modelObjectWrapper.getFitStatistic(mode='none')


ModelObjectWrapper:
    def fit( self, double ftol=1e-8, int verbose=-1, mode='LM', seed=0 ):
        cdef int solverID
        cdef string solverName
        status = self._model.FinalSetupForFitting()
        if status < 0:
            raise Exception('Failure in ModelObject::FinalSetupForFitting().')

NOTE that getFitStatistic method currently does *not* check to see if
FinalSetupForFitting was actually called!
	So one could plausibly call ModelObjectWrapper.loadData and then call
	ModelObjectWrapper.getFitStatistic -- without ModelObject::FinalSetupForFitting
	having been called!
	
	Currently, the code for Imfit does not allow this, because it does not allow
	the --fitstat-only mode (that is, Imfit.fit() loads the data *and* runs the
	fit, and there is no other way to load the data...)
	
	
REFACTORING:

So what we need is a method for Imfit class which
	-- loads data and image-description parameters and fit-statistic selection
	-- calls FinalSetupForFitting

and a separate method which initiates the actual fit
	-- specifies which solver to use
	-- initiates the fit

We need to modify ModelObjectWrapper
	1. loadData method should probably call
		status = self._model.FinalSetupForFitting()
	right at the end
	2. loadData should set an internal flag indicating that FinalSetupForFitting
	*has* been called
	
	3. fit method should *not* call self._model.FinalSetupForFitting()
	



