PLAN:

** GENERAL/FUTURE TO-DO

    * Packaging:
        * Make Python package (ignore Imfit library compilation for now)
            [x] Make text file summarizing how to compile/build package in current form

        * Test upload to TestPyPI and installation
            [x] Make virtualenv
            [x] Trial upload of wheel
            [x] Trial installation in virtualenv

        * Update README.md
            -- Will be seen on Github

        * Update/flesh out README_pyimfit.md
            -- Will be seen on PyPI

        * Include compilation of Imfit library
            [x] Look up notes on how to include Cython compilation in a package build

            http://martinsosic.com/development/2016/02/08/wrapping-c-library-as-python-module.html#summary

        * Figure out how to install cython and scons as part of general installation
            https://stackoverflow.com/questions/54117786/add-numpy-get-include-argument-to-setuptools-without-preinstalled-numpy

            [X] cython
                -- needed for cythonize in setup.py and for actual processing of .pyx into .cpp
                (possibly later we could relax this, by generating the .cpp files and making
                them part of the repo/distribution)
            [x] scons
                Need to locally/temporarily install scons as a Python package *and* have
                access to the "scons" binary
            [x] Figure out how to *remove* general SCons installation
                -- right now, if we download the precompiled binary version from test.pypi.org,
                it installs scons (in addition to pyimfit)


        * Test compilation in virtualenv with different compilers
            [x] Write notes/script to set up new virtualenv with bare essentials
            [x] Write notes/script for making clean setup of pyimfit
                -- scons -c on imfit subdir
                -- rm build/*, etc.
            [x] Write notes/script

            [x] Test with GCC-9

            [-] Test with Homebrew llvm

            [x] Write code to pass in user-specified CXX, CC to scons for building libimfit.a

        * Test installation on Linux
            [x] Test installation on Ubuntu 16 VM

        * See if Andre can test pip installation?
            [x] Email Andre about testing Mac installation via pip; Linux build from source

        * Modify setup.py to allow user to specify alternate library path for SCons build
        of libimfit.a
            [ ] Figure out how to add command-line option to setup.py for specifying
            lib-path


    * Documentation:
        [x] Check how to set up doc input files for readthedocs

            [x] Look up how to do Sphinx setup/quickstart (e.g., how to generate setup.py file)
            [x] Do Sphinx setup/quickstart

            [x] Test Sphinx documentation generation

       [x] Make basic how-to/summary files (useful for me)
        [x] Basic summary .rst file
            -- the main pieces
            -- how to assemble a model
            -- how to do a fit
            -- how to look at the results

       [ ] Add API documentation
            [ ] Add documentation file for config.py
            [ ] Add documentation file for descriptions.py
            [ ] Add documentation file for imfit_funcs.py
            [ ] Add documentation file for utils.py

    * Rework package to make it astropy-compatible

    * Decide on consistent use of "function set" vs "function block"


[ ] Fix broken SimpleModelDescription
    -- currently, if we create a "blank" SimpleModelDescription, we cannot add a FunctionSetDescription
    to it
    -- ideally, we should be able to instantiate SimpleModelDescription using
        a) an existing ModelDescription instance (with one function set)
        b) an existing FunctionSetDescription instance
        c) an existing FunctionDescription
    -- we should also be able to set the x0 and y0 values
    [ ] Create some tests in test_descriptions.py for how SimpleModelDescription should act
        [ ] Write test(s) instantiating from existing ModelDescription
            [x] Basic test
            [ ] Test that we raise exception for case of input ModelDescription with 2+ function sets
        [ ] Write test(s) instantiating from existing FunctionSetDescription
        [ ] Write test(s) instantiating from existing FunctionDescription
        [ ] Write test(s) modifying x0, y0


[x] Improvements/fixes to Imfit class
    [x] getModelImage -- allow user to specify new parameter vector
        makeimage_main.cpp:
            theModel->CreateModelImage(paramsVect);
            theModel->GetModelImageVector()

        [x] Add ability to specify optional/new parameter vector to ModelObjectWrapper
            -- Note that computeFitStatistic already allows this
            -- do we want to permanently update the internal parameter vector,
            or just temporarily?
        [x] Add keyword option for specifying new parameter array to Imfit.getModelImage()
    [x] Set up testing of Imfit.getModelImage(newParameters)
        [x] Write test code for FlatSky component, varying I_0 value

    [x] getModelFluxes and getModelMagnitudes -- ditto
        [x] Write unit tests
        [x] Modify ModelObjectWrapper.getModelFluxes to allow optional parameter vector
        [x] Modify ModelObjectWrapper.getModelMagnitudes to allow optional parameter vector

    [x] Catch possible error where user specifies alternate shape for model image
    via getModelImage when Imfit object already has that specified (e.g., via loadData)
        [x] Write unit test in test_fitting.py to catch this


[ ] Processing of makeimage config files
    -- We would like to be able to tell PyImfit to read a makeimage config file and set
    up the model accordingly, *including* the image dimensions (if supplied)


[ ] LATER: handle resizing of model image and/or new
    -- This will require changing Imfit to allow resizing, new data, etc.
    Alternately (and probably simpler), this will require allowing Imfit to
    discard the old ModelObjectWrapper and properly initialize a new one
    -- Note that self._dataSet records if we have called loadData, and thus whether or
    not a data image, etc. (including image size) has been added
    [ ] Resizing of model image
    [ ] Changing image-description parameters
    [ ] Changing PSF image(s)
    [ ] Changing data image (can include resizing of model image)


[x] Computation of total and individual-function fluxes, magnitudes
    -- e.g., equivalent of makeimage --print-fluxes
    -- option/method: total flux only (with zero point as optional parameter)
    -- option/method: fluxes for individual functions (with zero point as optional parameter)
    [x] Create unit-test file
    [x] Create preliminary unit tests
    [x] Write code to pass unit tests


[x] Method to save best-fit parameters (e.g., in Imfit object) to imfit/makeimage-compatible output
    file
    -- We should actually be able to do two things
        1. Save best-fit parameters to something like a standard imfit best-fit output file
        2. Save a model to something like a standard imfit config file (including GAIN, etc.)
            -- e.g., if we construct a model in Python, and then want to save it to a file

    [x] Check to see if code for this already exists [no]
    [x] Add code to ModelDescription to save model description to file
        [x] Add code to ParameterDescription to output formatted string
            [x] Add code to unit test (test_description.py)
            [x] Write code to pass test
        [x] Add code to ParameterDescription to output formatted string w/ optional errors (no limit info)
            [x] Add code to unit tests (test_description.py) -- no errors
            [x] Add code to unit tests (test_description.py) -- with errors
            [x] Write code to pass tests
        [x] Add code to FunctionDescription to output list of formatted strings
            [x] Add code to unit test (test_description.py)
            [x] Write code to pass test
        [x] Add code to FunctionDescription to output list of formatted strings w/ optional errors (no limit info)
            [x] Add code to unit tests (test_description.py) -- no errors
            [x] Add code to unit tests (test_description.py) -- with errors
            [x] Write code to pass tests
        [x] Add code to FunctionSetDescription to output list of formatted strings
            [x] Add code to unit test (test_description.py)
            [x] Write code to pass test
        [x] Add code to FunctionSetDescription to output list of formatted strings w/ optional errors (no limit info)
            [x] Add code to unit test (test_description.py) -- no errors
            [x] Add code to unit test (test_description.py) -- with errors (or noLimits=True)
            [x] Write code to pass test
        [x] Add code to save ModelDescription as imfit config file (GAIN, parameter limits, etc.)
            [x] Add code to unit test (test_description.py)
            [x] Write code to pass test
        [x] Add code to save ModelDescription as imfit output file (no GAIN, etc.; should include
            parameter errors, if they exist)
    [x] Add code to Imfit to do same (should call method on internal
        e.g., use getModelDescription(), then pass parameters to the resulting ModelDescription object
            [x] Test Imfit.saveCurrentModelToFile()
                [x] Test saving model prior to fit
                [x] Run fit with NM (no parameter errors)
                [x] Run fit with LM (parameter errors)
            [x] includeImageOptions=True doesn't actually save image options if they're provided
            in the Imfit.fit method
            -- OK, the problem is:
                1. How do we save keyword values passed in when .fit() or .loadData() [called by fit]
                are called (currently, these are passed on to _modelObjectWrapper.loadData)
                2. ModelDescription.getStringDescription needs to be able to
    [x] Add code for updating ModelDescription option within Imfit
        -- use ModelDescription.updateOptions()
        [x] Write _updateModelDescription
            [x] Write unit test for Imfit._updateModelDescription
            [x] Write code to pass test
        [x] Test to see if Imfit.saveCurrentModelToFile() correctly saves user-supplied image options


[ ] Experiment with building using shared libraries
    -- Build shared Imfit library (possibly using shared fftw3, etc. libraries)
    -- Install shared Imfit library
        -- Also need to install header files
    -- Build pyimfit using shared Imfit library


[X] We need the following internal flag variables in Imfit:
	has-FinalSetupForFitting-been-called?
		_finalSetupDone
	has-fit-been-done? (converged *or* terminated)
		_fitDone
	has-fit-statistic-been-computed?
		_fitStatComputed

	Currently, Imfit has the following *properties*:
		.fitConverged = return self._modelObjectWrapper.fitConverged
			= [ModelObjectWrapper] return (self._fitStatus > 0) and (self._fitStatus < 5)
		.fitTerminated = return self._modelObjectWrapper.fitTerminated
			= [ModelObjectWrapper] return self._fitStatus >= 5

	In ModelObjectWrapper
		_fitStatus = int, initially 0; then = return value from DispatchToSolver

[X] Imfit.doFit method
	-- specifies which solver to use
	-- initiates the fit

	[X] doFit method
    def doFit( self, solver='LM' ):
        if solver not in ['LM', 'NM', 'DE']:
            raise Exception('Invalid solver name: {0}'.format(solver))
        self._modelObjectWrapper.fit(verbose=self._verboseLevel, mode=solver)
        if not self.fitError:
            self._fitDone = True
            self._fitStatComputed = True

	[X] Modify ModelObjectWrapper.fit
		-- *remove* self._model.FinalSetupForFitting() call

	[X] ModelObjectWrapper.doFinalSetup method
		-- if NOT _finalSetupDone: calls ModelObject::FinalSetupForFitting

[X] Imfit.loadData method
	-- optional PSF data
		-- set this first!
	-- loads data and image-description parameters and fit-statistic selection
	-- calls FinalSetupForFitting
	[X] Main refactoring (don't include PSF option)

	[X] Modify ModelObjectWrapper.loadData
		-- status = self._model.FinalSetupForFitting() right at the end
		-- set internal _finalSetupDone flag

	[X] Add PSF option

[X] Refactor existing Imfit.fit method to call .loadData and then .doFit
	[X] Refactor
	[X] Run unit & regression tests


[x] Test use of PSF convolution in computation of fit statistics and fitting
    PSF convolution in test_fitting_and_fitstatistic.py is currently not working!
    -- Problem is: PSF image is *not* being normalized?
    Normalization w/in C++ imfit (setup_model_object.cpp):
    status = newModelObj->AddPSFVector(nPixels_psf, nColumns_psf, nRows_psf, psfPixels,
    									options->normalizePSF);

    Normalization in pyimfit
       def setPSF(self, np.ndarray[np.double_t, ndim=2, mode='c'] psf):
        self._model.AddPSFVector(n_cols_psf * n_rows_psf, n_cols_psf, n_rows_psf, &self._psfData[0])

    def _setupModel(self):
           if self._psf is not None:
            self._modelObjectWrapper.setPSF(np.asarray(self._psf))

    [x] Add normalize option/keyword to Imfit class
        [x] Add as property with default value = True

        [x] Modify Imfit._setupModel to include normalize flag value as input to setPSF

        [x] Modify ModelObjectWrapper.setPSF to accept normalization flag and pass it on
        to ModelObject::AddPSFVector

        [x] Run tests in test_fitting_and_fitstatistic.py

        [x] Add option for specifying *no* PSF normalization
            -- should be sample place we pass in the PSF image!




[ ] Modify Imfit: add ability to change parameter *values*
	[x]-- necessary if we want to use Imfit to get fit statistic *without* running
	a fit
	-- useful if user wants to re-run a fit with different starting parameters
	-- for now: we want to be able to supply a list/ndarray of parameter *values*,
	without touching the parameter limits
	-- Two modes:
		[x]1. Pass parameter values to ModelObject::GetFitStatistic
		2. Update the parameter values in Imfit object (for future fits)

	Current ModelObjectWrapper.getFitStatistic(mode) does this:
    def getFitStatistic( self, mode='none' ):
        cdef double fitstat
        if self.fittedLM: -- i.e., if there was a successful fit with LM
            fitstat = self._fitResult.bestnorm
        else:
            fitstat = self._model.GetFitStatistic(self._paramVect)

	[and then returns a modified value -- e.g., reduced, AIC, BIC -- depending
	on value of "mode"]

	[X] New method in ModelObjectWrapper
	computeFitStatistic( self, parameterVector=None ):
		[ type for parameterVector = np.ndarray[np.double_t, ndim=1, mode='c'] ?]
		if parameterVictor is None:
			fitstat = self._model.GetFitStatistic(self._paramsVect)
		else:
			# possibly convert parameterVector to double *
			fitstat = self._model.GetFitStatistic(parameterVector)

	[X] Corresponding method for Imfit

	[X] Add extra unit tests


	Basically, we need to update ModelObjectWrapper._paramVect

	[ ] Updating of current parameter vector in ModelObjectWrapper:
		[ ] Quick and dirty modification:
			[ ] Add .updateParameterValues method to ModelObjectWrapper
				-- should update ModelObjectWrapper._paramVect
			[ ] Add .updateParameterValues method to Imfit
				-- should call ModelObjectWrapper._paramVect on self._modelObjectWrapper


	MAYBE LATER:
	[ ] Check to see if there's a way to modify parameter values in an existing
	ModelDescription instance

	[ ] Modify ParameterDescription
		[ ] Change "value" property so we can set it as well as read it

	[ ] Modify ModelDescription
		[ ] ModelDesription.updateParameterValues

	[ ] Modify Imfit to allow updating of parameter values
		-- i.e., call

[X] Test whether we can call Imfit.fitStatistic w/o running fit



** [X] ADD OVERSAMPLED-PSF SUPPORT TO PYIMFIT

In current imfit/makeimage code, this is done in SetupModelObject

  [[ *after* PSF vector is added, if any ]]

  [[ *after* adding data image [or specifying model image size in makeimage mode] ]]
    -- this also makes sense from the standpoint of wanting to have the data/model
    image dimensions so we can tell if the oversampling regions are within the image

  if (options->psfOversampling) {
    for (int i = 0; i < (int)psfOversampleInfoVect.size(); i++) {
      status = newModelObj->AddOversampledPsfInfo(psfOversampleInfoVect[i]);
      if (status < 0) {
        fprintf(stderr, "*** ERROR: Failure in ModelObject::AddOversampledPsfInfo!\n\n");
  	    exit(-1);
      }
    }
  }


So we need a way of creating PsfOversamplingInfo objects, and passing pointers
to them
    We need to add PsfOversamplingInfo to ModelObjectWrapper, via Imfit
    -- PsfOversamplingInfo can only be added to ModelObject
        1. *After* data image added (or model image setup):
            nDataColumns and nDataRows must already be set
        2. *After* PSF image (if any) has been added

    Current way to do this is via keyword in call to ModelObjectWrapper.loadData()
        psf_oversampling_list

    [X] Add declaration of PsfOversamplingInfo to imfit_lib.pxd

    [X] Figure out when we need to or can add psf oversampling info to ModelObject
        *After* data image added (or model image setup):
            nDataColumns and nDataRows must already be set
        *After* PSF image (if any) has been added

    [X] Add keyword parameter for oversampling-info objects to ModelObjectWrapper.

    [X] Add wrapper method around ModelObject::AddOversampledPsfInfo to ModelObjectWrapper

    [X] Make unit/regression test for use of PSF oversampling

    [ ] Later: add separate method to Imfit class allowing user to pass in
    just the oversampling info?


ModelObjectWrapper:
    cdef addOversamplingInfo(self, PsfOversampling oversamplingInfo):


    keyword in loadData:
       psf_oversampling_list : list of PsfOversampling
            List of PsfOversampling objects, describing oversampling regions, PSFs,
            and oversampling scales.






* As a reminder, imfit does the following, in this order
1. Creates ModelObject and loads data, error, mask, PSF, image-description info
(via SetupModelObject)
	Adds PSF *first*, then adds data, etc. [because when we add data with
	AddImageDataVector, SetupModelImage is then automatically called, and
	the internal model-image dimensions are determined, and so *if* we're
	using a PSF, its dimensions need to already be in place]
	

2. Adds image functions to ModelObject (via AddFunctions)

[I *believe* that 1 and 2 can be done in either order...]

3. ModelObject->FinalSetupForFitting()

[then we add info about parameter, etc.]


    imfit_fitter = Imfit(model_desc)
    imfit_fitter.loadData(image_ic3478, gain=4.725, read_noise=4.3, original_sky=130.14)


* pyimfit currently works this way
1. Instantiate Imfit object, storing the input ModelDescription and PSF data
    ex: imfit_fitter = Imfit(model_desc)
    ex: imfit_fitter = Imfit(model_desc, psfImage)

2. Supply image data (and image-description info, like gain)
    ex: imfit_fitter.loadData(image_ic3478, gain=4.725, read_noise=4.3, original_sky=130.14)

3. Call Imfit.fit, which
	A. calls _setupModel(), which instantiates ModelObjectWrapper object, 
	passing it the ModelDescription
	Then, inside ModelObjectWrapper, we do
		self._model = new ModelObject()
        self._model.SetDebugLevel(debug_level)
        self._model.SetVerboseLevel(verbose_level)
        self._addFunctions(self._modelDescr, subsampling=subsampling, verbose=verbose_level)
        self._paramSetup(self._modelDescr)
        
    Then, PSF data (if any) is passed to ModelObjectWrapper object via
    	self._modelObjectWrapper.setPSF(np.asarray(self._psf))

	B. Sends data, etc. to ModelObjectWrapper object via
		self._modelObjectWrapper.loadData(image, error, mask, **kwargs)
		
	C. Calls FinalSetupForFitting *and* initiates the fit via
		self._modelObjectWrapper.fit(verbose=self._verboseLevel, mode=mode)

So, in conceptual summary
	1. Create ModelObject and add functions (and param info)
	2. Add PSF
	3. Add data
	4. FinalSetupForFitting()
	5. Run fit


model_object.cpp:
/* ---------------- PUBLIC METHOD: SetupModelImage -------------------- */
// Called by AddImageDataVector(); can also be used by itself in make-image
// mode. Tells ModelObject to allocate space for the model image.
// Note that if PSF convolution is being done, then AddPSFVector() must be
// called *before* this method.



supply data
supply PSF
	==> call FinalSetupForFitting

supply PSF
supply data
	==> call FinalSetupForFitting

supply data (not using PSF)
	==> ??

Why we might want to supply PSF *first*, separate from data image, etc.
	-- What if user wants to re-run fit with updated mask image?
	-- What if user wants to re-run fit with changed image section?


1. Add doFinalSetup method to Imfit (and ModelObjectWrapper)

2. Modify ModelObjectWrapper.fit so that it checks to see if ModelObject::FinalSetupForFitting
has already been called; if not, 



PROBLEMS:

When user calls Imfit.fitStatistic, .reducedFitStatistic, .AIC, or .BIC
	-- Do we re-compute the fit statistic?
	-- What if fit statistic already exists?


Imfit.fit(...)
        self._modelObjectWrapper.loadData(image, error, mask, **kwargs)
        self._dataSet = True
        self._modelObjectWrapper.fit(verbose=self._verboseLevel, mode=mode)

    @property
    def fitStatistic(self):
        """
        The :math:`\\chi^2`, Poisson MLR, or Cash statistic of the fit.
        """
        return self._modelObjectWrapper.getFitStatistic(mode='none')


ModelObjectWrapper:
    def fit( self, double ftol=1e-8, int verbose=-1, mode='LM', seed=0 ):
        cdef int solverID
        cdef string solverName
        status = self._model.FinalSetupForFitting()
        if status < 0:
            raise Exception('Failure in ModelObject::FinalSetupForFitting().')

NOTE that getFitStatistic method currently does *not* check to see if
FinalSetupForFitting was actually called!
	So one could plausibly call ModelObjectWrapper.loadData and then call
	ModelObjectWrapper.getFitStatistic -- without ModelObject::FinalSetupForFitting
	having been called!
	
	Currently, the code for Imfit does not allow this, because it does not allow
	the --fitstat-only mode (that is, Imfit.fit() loads the data *and* runs the
	fit, and there is no other way to load the data...)
	
	
REFACTORING:

So what we need is a method for Imfit class which
	-- loads data and image-description parameters and fit-statistic selection
	-- calls FinalSetupForFitting

and a separate method which initiates the actual fit
	-- specifies which solver to use
	-- initiates the fit

We need to modify ModelObjectWrapper
	1. loadData method should probably call
		status = self._model.FinalSetupForFitting()
	right at the end
	2. loadData should set an internal flag indicating that FinalSetupForFitting
	*has* been called
	
	3. fit method should *not* call self._model.FinalSetupForFitting()

