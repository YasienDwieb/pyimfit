PLAN:

** GENERAL/FUTURE TO-DO

    * Packaging:
        * Make Python package (ignore Imfit library compilation for now)
            [x] Make text file summarizing how to compile/build package in current form

        * Test upload to TestPyPI and installation
            [x] Make virtualenv
            [x] Trial upload of wheel
            [x] Trial installation in virtualenv

        * Update README.md
            -- Will be seen on Github

        * Update/flesh out README_pyimfit.md
            -- Will be seen on PyPI

        * Include compilation of Imfit library
            [ ] Look up notes on how to include Cython compilation in a package build

            http://martinsosic.com/development/2016/02/08/wrapping-c-library-as-python-module.html#summary

    * Documentation:
        [ ] Check how to set up doc input files for readthedocs

            [x] Look up how to do Sphinx setup/quickstart (e.g., how to generate setup.py file)
            [x] Do Sphinx setup/quickstart

            [x] Test Sphinx documentation generation

       [ ] Make basic how-to/summary file (useful for me)

       [ ] Add API documentation
            [ ] Add documentation file for config.py
            [ ] Add documentation file for descriptions.py
            [ ] Add documentation file for imfit_funcs.py
            [ ] Add documentation file for utils.py

    * Rework package to make it astropy-compatible




[ ] Method to save best-fit parameters (e.g., in Imfit object) to imfit/makeimage-compatible output
    file
    -- We should actually be able to do two things
        1. Save best-fit parameters to something like a standard imfit best-fit output file
        2. Save a model to something like a standard imfit config file (including GAIN, etc.)
            -- e.g., if we construct a model in Python, and then want to save it to a file

    [x] Check to see if code for this already exists [no]
    [ ] Add code to ModelDescription to save model description to file
        [x] Add code to ParameterDescription to output formatted string
            [x] Add code to unit test (test_description.py)
            [x] Write code to pass test
        [x] Add code to ParameterDescription to output formatted string w/ optional errors (no limit info)
            [x] Add code to unit tests (test_description.py) -- no errors
            [x] Add code to unit tests (test_description.py) -- with errors
            [x] Write code to pass tests
        [x] Add code to FunctionDescription to output list of formatted strings
            [x] Add code to unit test (test_description.py)
            [x] Write code to pass test
        [x] Add code to FunctionDescription to output list of formatted strings w/ optional errors (no limit info)
            [x] Add code to unit tests (test_description.py) -- no errors
            [x] Add code to unit tests (test_description.py) -- with errors
            [x] Write code to pass tests
        [x] Add code to FunctionSetDescription to output list of formatted strings
            [x] Add code to unit test (test_description.py)
            [x] Write code to pass test
        [ ] Add code to FunctionSetDescription to output list of formatted strings w/ optional errors (no limit info)
            [ ] Add code to unit test (test_description.py) -- no errors
            [ ] Add code to unit test (test_description.py) -- with errors (or noLimits=True)
            [ ] Write code to pass test
        [ ] Add code to save ModelDescription as imfit config file (GAIN, parameter limits, etc.)
            [ ] Add code to unit test (test_description.py)
            [ ] Write code to pass test
        [ ] Add code to save ModelDescription as imfit output file (no GAIN, etc.; should include
            parameter errors, if they exist)
    [ ] Add code to Imfit to do same (should call method on internal
        e.g., use getModelDescription(), then pass parameters to the resulting ModelDescription object


[ ] Experiment with building using shared libraries
    -- Build shared Imfit library (possibly using shared fftw3, etc. libraries)
    -- Install shared Imfit library
        -- Also need to install header files
    -- Build pyimfit using shared Imfit library


[X] We need the following internal flag variables in Imfit:
	has-FinalSetupForFitting-been-called?
		_finalSetupDone
	has-fit-been-done? (converged *or* terminated)
		_fitDone
	has-fit-statistic-been-computed?
		_fitStatComputed

	Currently, Imfit has the following *properties*:
		.fitConverged = return self._modelObjectWrapper.fitConverged
			= [ModelObjectWrapper] return (self._fitStatus > 0) and (self._fitStatus < 5)
		.fitTerminated = return self._modelObjectWrapper.fitTerminated
			= [ModelObjectWrapper] return self._fitStatus >= 5

	In ModelObjectWrapper
		_fitStatus = int, initially 0; then = return value from DispatchToSolver

[X] Imfit.doFit method
	-- specifies which solver to use
	-- initiates the fit

	[X] doFit method
    def doFit( self, solver='LM' ):
        if solver not in ['LM', 'NM', 'DE']:
            raise Exception('Invalid solver name: {0}'.format(solver))
        self._modelObjectWrapper.fit(verbose=self._verboseLevel, mode=solver)
        if not self.fitError:
            self._fitDone = True
            self._fitStatComputed = True

	[X] Modify ModelObjectWrapper.fit
		-- *remove* self._model.FinalSetupForFitting() call

	[X] ModelObjectWrapper.doFinalSetup method
		-- if NOT _finalSetupDone: calls ModelObject::FinalSetupForFitting

[X] Imfit.loadData method
	-- optional PSF data
		-- set this first!
	-- loads data and image-description parameters and fit-statistic selection
	-- calls FinalSetupForFitting
	[X] Main refactoring (don't include PSF option)

	[X] Modify ModelObjectWrapper.loadData
		-- status = self._model.FinalSetupForFitting() right at the end
		-- set internal _finalSetupDone flag

	[X] Add PSF option

[X] Refactor existing Imfit.fit method to call .loadData and then .doFit
	[X] Refactor
	[X] Run unit & regression tests


[x] Test use of PSF convolution in computation of fit statistics and fitting
    PSF convolution in test_fitting_and_fitstatistic.py is currently not working!
    -- Problem is: PSF image is *not* being normalized?
    Normalization w/in C++ imfit (setup_model_object.cpp):
    status = newModelObj->AddPSFVector(nPixels_psf, nColumns_psf, nRows_psf, psfPixels,
    									options->normalizePSF);

    Normalization in pyimfit
       def setPSF(self, np.ndarray[np.double_t, ndim=2, mode='c'] psf):
        self._model.AddPSFVector(n_cols_psf * n_rows_psf, n_cols_psf, n_rows_psf, &self._psfData[0])

    def _setupModel(self):
           if self._psf is not None:
            self._modelObjectWrapper.setPSF(np.asarray(self._psf))

    [x] Add normalize option/keyword to Imfit class
        [x] Add as property with default value = True

        [x] Modify Imfit._setupModel to include normalize flag value as input to setPSF

        [x] Modify ModelObjectWrapper.setPSF to accept normalization flag and pass it on
        to ModelObject::AddPSFVector

        [x] Run tests in test_fitting_and_fitstatistic.py

        [x] Add option for specifying *no* PSF normalization
            -- should be sample place we pass in the PSF image!




[ ] Modify Imfit: add ability to change parameter *values*
	-- necessary if we want to use Imfit to get fit statistic *without* running
	a fit
	-- useful if user wants to re-run a fit with different starting parameters
	-- for now: we want to be able to supply a list/ndarray of parameter *values*,
	without touching the parameter limits
	-- Two modes:
		1. Pass parameter values to ModelObject::GetFitStatistic
		2. Update the parameter values in Imfit object (for future fits)

	Current ModelObjectWrapper.getFitStatistic(mode) does this:
    def getFitStatistic( self, mode='none' ):
        cdef double fitstat
        if self.fittedLM: -- i.e., if there was a successful fit with LM
            fitstat = self._fitResult.bestnorm
        else:
            fitstat = self._model.GetFitStatistic(self._paramVect)

	[and then returns a modified value -- e.g., reduced, AIC, BIC -- depending
	on value of "mode"]

	[X] New method in ModelObjectWrapper
	computeFitStatistic( self, parameterVector=None ):
		[ type for parameterVector = np.ndarray[np.double_t, ndim=1, mode='c'] ?]
		if parameterVictor is None:
			fitstat = self._model.GetFitStatistic(self._paramsVect)
		else:
			# possibly convert parameterVector to double *
			fitstat = self._model.GetFitStatistic(parameterVector)

	[X] Corresponding method for Imfit

	[X] Add extra unit tests


	Basically, we need to update ModelObjectWrapper._paramVect

	[ ] Updating of current parameter vector in ModelObjectWrapper:
		[ ] Quick and dirty modification:
			[ ] Add .updateParameterValues method to ModelObjectWrapper
				-- should update ModelObjectWrapper._paramVect
			[ ] Add .updateParameterValues method to Imfit
				-- should call ModelObjectWrapper._paramVect on self._modelObjectWrapper


	MAYBE LATER:
	[ ] Check to see if there's a way to modify parameter values in an existing
	ModelDescription instance

	[ ] Modify ParameterDescription
		[ ] Change "value" property so we can set it as well as read it

	[ ] Modify ModelDescription
		[ ] ModelDesription.updateParameterValues

	[ ] Modify Imfit to allow updating of parameter values
		-- i.e., call

[X] Test whether we can call Imfit.fitStatistic w/o running fit



** ADD OVERSAMPLED-PSF SUPPORT TO PYIMFIT

In current imfit/makeimage code, this is done in SetupModelObject

  [[ *after* PSF vector is added, if any ]]

  [[ *after* adding data image [or specifying model image size in makeimage mode] ]]
    -- this also makes sense from the standpoint of wanting to have the data/model
    image dimensions so we can tell if the oversampling regions are within the image

  if (options->psfOversampling) {
    for (int i = 0; i < (int)psfOversampleInfoVect.size(); i++) {
      status = newModelObj->AddOversampledPsfInfo(psfOversampleInfoVect[i]);
      if (status < 0) {
        fprintf(stderr, "*** ERROR: Failure in ModelObject::AddOversampledPsfInfo!\n\n");
  	    exit(-1);
      }
    }
  }


So we need a way of creating PsfOversamplingInfo objects, and passing pointers
to them
    We need to add PsfOversamplingInfo to ModelObjectWrapper, via Imfit
    -- PsfOversamplingInfo can only be added to ModelObject
        1. *After* data image added (or model image setup):
            nDataColumns and nDataRows must already be set
        2. *After* PSF image (if any) has been added

    Current way to do this is via keyword in call to ModelObjectWrapper.loadData()
        psf_oversampling_list

    [X] Add declaration of PsfOversamplingInfo to imfit_lib.pxd

    [X] Figure out when we need to or can add psf oversampling info to ModelObject
        *After* data image added (or model image setup):
            nDataColumns and nDataRows must already be set
        *After* PSF image (if any) has been added

    [X] Add keyword parameter for oversampling-info objects to ModelObjectWrapper.

    [X] Add wrapper method around ModelObject::AddOversampledPsfInfo to ModelObjectWrapper

    [X] Make unit/regression test for use of PSF oversampling

    [ ] Later: add separate method to Imfit class allowing user to pass in
    just the oversampling info?


ModelObjectWrapper:
    cdef addOversamplingInfo(self, PsfOversampling oversamplingInfo):


    keyword in loadData:
       psf_oversampling_list : list of PsfOversampling
            List of PsfOversampling objects, describing oversampling regions, PSFs,
            and oversampling scales.






* As a reminder, imfit does the following, in this order
1. Creates ModelObject and loads data, error, mask, PSF, image-description info
(via SetupModelObject)
	Adds PSF *first*, then adds data, etc. [because when we add data with
	AddImageDataVector, SetupModelImage is then automatically called, and
	the internal model-image dimensions are determined, and so *if* we're
	using a PSF, its dimensions need to already be in place]
	

2. Adds image functions to ModelObject (via AddFunctions)

[I *believe* that 1 and 2 can be done in either order...]

3. ModelObject->FinalSetupForFitting()

[then we add info about parameter, etc.]


    imfit_fitter = Imfit(model_desc)
    imfit_fitter.loadData(image_ic3478, gain=4.725, read_noise=4.3, original_sky=130.14)


* pyimfit currently works this way
1. Instantiate Imfit object, storing the input ModelDescription and PSF data
    ex: imfit_fitter = Imfit(model_desc)
    ex: imfit_fitter = Imfit(model_desc, psfImage)

2. Supply image data (and image-description info, like gain)
    ex: imfit_fitter.loadData(image_ic3478, gain=4.725, read_noise=4.3, original_sky=130.14)

3. Call Imfit.fit, which
	A. calls _setupModel(), which instantiates ModelObjectWrapper object, 
	passing it the ModelDescription
	Then, inside ModelObjectWrapper, we do
		self._model = new ModelObject()
        self._model.SetDebugLevel(debug_level)
        self._model.SetVerboseLevel(verbose_level)
        self._addFunctions(self._modelDescr, subsampling=subsampling, verbose=verbose_level)
        self._paramSetup(self._modelDescr)
        
    Then, PSF data (if any) is passed to ModelObjectWrapper object via
    	self._modelObjectWrapper.setPSF(np.asarray(self._psf))

	B. Sends data, etc. to ModelObjectWrapper object via
		self._modelObjectWrapper.loadData(image, error, mask, **kwargs)
		
	C. Calls FinalSetupForFitting *and* initiates the fit via
		self._modelObjectWrapper.fit(verbose=self._verboseLevel, mode=mode)

So, in conceptual summary
	1. Create ModelObject and add functions (and param info)
	2. Add PSF
	3. Add data
	4. FinalSetupForFitting()
	5. Run fit


model_object.cpp:
/* ---------------- PUBLIC METHOD: SetupModelImage -------------------- */
// Called by AddImageDataVector(); can also be used by itself in make-image
// mode. Tells ModelObject to allocate space for the model image.
// Note that if PSF convolution is being done, then AddPSFVector() must be
// called *before* this method.



supply data
supply PSF
	==> call FinalSetupForFitting

supply PSF
supply data
	==> call FinalSetupForFitting

supply data (not using PSF)
	==> ??

Why we might want to supply PSF *first*, separate from data image, etc.
	-- What if user wants to re-run fit with updated mask image?
	-- What if user wants to re-run fit with changed image section?


1. Add doFinalSetup method to Imfit (and ModelObjectWrapper)

2. Modify ModelObjectWrapper.fit so that it checks to see if ModelObject::FinalSetupForFitting
has already been called; if not, 



PROBLEMS:

When user calls Imfit.fitStatistic, .reducedFitStatistic, .AIC, or .BIC
	-- Do we re-compute the fit statistic?
	-- What if fit statistic already exists?


Imfit.fit(...)
        self._modelObjectWrapper.loadData(image, error, mask, **kwargs)
        self._dataSet = True
        self._modelObjectWrapper.fit(verbose=self._verboseLevel, mode=mode)

    @property
    def fitStatistic(self):
        """
        The :math:`\\chi^2`, Poisson MLR, or Cash statistic of the fit.
        """
        return self._modelObjectWrapper.getFitStatistic(mode='none')


ModelObjectWrapper:
    def fit( self, double ftol=1e-8, int verbose=-1, mode='LM', seed=0 ):
        cdef int solverID
        cdef string solverName
        status = self._model.FinalSetupForFitting()
        if status < 0:
            raise Exception('Failure in ModelObject::FinalSetupForFitting().')

NOTE that getFitStatistic method currently does *not* check to see if
FinalSetupForFitting was actually called!
	So one could plausibly call ModelObjectWrapper.loadData and then call
	ModelObjectWrapper.getFitStatistic -- without ModelObject::FinalSetupForFitting
	having been called!
	
	Currently, the code for Imfit does not allow this, because it does not allow
	the --fitstat-only mode (that is, Imfit.fit() loads the data *and* runs the
	fit, and there is no other way to load the data...)
	
	
REFACTORING:

So what we need is a method for Imfit class which
	-- loads data and image-description parameters and fit-statistic selection
	-- calls FinalSetupForFitting

and a separate method which initiates the actual fit
	-- specifies which solver to use
	-- initiates the fit

We need to modify ModelObjectWrapper
	1. loadData method should probably call
		status = self._model.FinalSetupForFitting()
	right at the end
	2. loadData should set an internal flag indicating that FinalSetupForFitting
	*has* been called
	
	3. fit method should *not* call self._model.FinalSetupForFitting()



** BUILDING ON LINUX

The build approach for the pyimfit package that works on macOS doesn't work on Linux,
because when g++ is called to build the Cython-generated library, it expects the
imfit lib to have been built with position-independent code ("PIC"). The result is the
following somewhat cryptic error message:

[generated by python3 setup.py build:]
$ g++ -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions -Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,\
-Bsymbolic-functions -Wl,-z,relro -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time \
-D_FORTIFY_SOURCE=2 build/temp.linux-x86_64-3.6/pyimfit/pyimfit_lib.o -Limfit -limfit -lcfitsio -lgsl \
-lgslcblas -lnlopt -lfftw3 -lfftw3_threads -o build/lib.linux-x86_64-3.6/pyimfit/pyimfit_lib.cpython-36m-x86_64-linux-gnu.so -fopenmp

[error messages:]
/usr/bin/ld: imfit/libimfit.a(model_object.o): relocation R_X86_64_PC32 against symbol `_ZTV11ModelObject' \
can not be used when making a shared object; recompile with -fPIC

Apparent solution: use "-fPIC" flag when compiling libimfit.a [and also when compiling the FFTW3 static
libraries; it seems this is not a problem for the other libraries, possibly because they're already
complied with "-fPIC")



FIXES ATTEMPTED:
    * Use non-specific-version of GCC on Linux
        -- currently, setup.py specifies g++-8 (for use on Mac)
        -- our VirtualBox Ubuntu 18.04 machine only has gcc-5

    * Build static libraries with -fPIC
        -- this seems to be necessary if we want to link a static library (libimfit.a, libfftw3.a, etc.)
        into a *shared* library (our target pyimfit.so)
        1. Edit imfit/SConstruct to specify -fPIC for all compilation
        2. Compile FFTW3 to include PIC
            $ ./configure --with-pic --enable-threads --enable-sse2 --enable-avx
        3. Recompile libimfit.a [so it links in code from updated libfftw3.a]


OK, it turns out we *cannot* build a Linux binary wheel for upload to PyPI because PyPI
will not accept them!
This is actually deliberate policy, apparently due to problems with incompatibilities
between different flavors of Linux, and uncertainties about which libraries may or may
not be present.

There is a proposed "Linux standard" for binary wheels called "manylinux1", but it's unclear
if this is really supported yet, and it may be rather difficult.

https://www.python.org/dev/peps/pep-0513/


** NOTES FOR COMPILING IMFIT LIBRARY

Remove dependence on cfitsio? [assuming user will read in FITS files using astropy.io.fits
or something like that]

Check for availability of OpenMP; if not there, turn off OpenMP during compilation

